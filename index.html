<!DOCTYPE html>
<!-- saved from url=(0042)http://cs.lmu.edu/~ray/notes/nasmexamples/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>NASM Examples</title>
<link rel="stylesheet" type="text/css" href="./default.css">
<link rel="stylesheet" type="text/css" href="./prettify.css">
<script type="text/javascript" src="./prettify.js"></script><style type="text/css"></style>
</head>
<body class="coursenotes">
<script type="text/javascript">onload = prettyPrint;</script>
<div class="container">
<div class="innercontent">
<h1>NASM 示例 </h1>

<div class="abstract">NASM 是一个绝赞的汇编器。现在让我们通过一些例子来学习 NASM。
然而这里的笔记仅仅只是蜻蜓点水般地涉及了一些皮毛，所以当你看完这个页面后，
你需要查看 <a href="http://www.nasm.us/doc/"> 官方的 NASM 文档 </a>。</div>

<h2> 准备工作 </h2>

<p> 请注意：除了最后的几个部分，这里列举的所有例子需要运行在 <strong> 一个 64 位的 Linux 系统上 </strong>。</p>

<p> 请确保已经安装好 nasm 和 gcc。</p>

<h2> 入门 </h2>

<p> 我们的第一个程序将使用 Linux 下的 1 号系统调用来输出一条信息和 60 号系统调用来退出程序。</p>

<div class="filename"><span>hello.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; ----------------------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 仅使用系统调用来输出 "Hello, World" 到控制台。 这个程序仅在 64 位的 Linux 下运行。</span><span class="pln"><br></span><span class="com">; 如何编译执行:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; &nbsp; nasm -felf64 hello.asm &amp;&amp; ld hello.o &amp;&amp; ./a.out</span><span class="pln"><br></span><span class="com">; ----------------------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;_start<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>_start:<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; write(1, message, 13)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 1 号系统调用是写操作 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 1 号文件系统调用是标准输出 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln">, message &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 输出字符串的地址 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdx</span><span class="pln">, 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 字符串的长度 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; syscall &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 调用系统执行写操作 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; exit(0)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">eax</span><span class="pln">, 60 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 60 号系统调用是退出 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 0 号系统调用作为退出 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; syscall &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 调用系统执行退出 </span><span class="pln"><br>message:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"Hello, World", 10 &nbsp; &nbsp; &nbsp;</span><span class="com">; 注意到最后的换行 </span></pre>
<pre class="console">$ <kbd>nasm -felf64 hello.asm &amp;&amp; ld hello.o &amp;&amp; ./a.out</kbd>
Hello, World
</pre>

<h2> 调用一个 C 语言库 </h2>

<p> 记得 C 程序为何看上去总是从 "main" 函数开始执行吗？实际上，因为在 C 语言库的内部有一个 <code>_start</code> 标签! 在 <code>_start</code> 处的代码首先会做一些初始化的工作，然后调用 <code>main</code> 函数，最后会做一些清理工作，最终执行 60 号系统系统调用。因此，你只需要实现 <code>main</code> 函数。我们在汇编中可以这么做：

</p><div class="filename"><span>hola.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; ----------------------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 使用 C 语言库在控制台输出 "Hola, mundo"。程序运行在 Linux 或者其他在 C 语言库中不使用下划线的操作系统上。</span><span class="pln"><br></span><span class="com">; 如何编译执行:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; &nbsp; nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><span class="pln"><br></span><span class="com">; ----------------------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;puts<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>main: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 被 C 语言库的初始化代码所调用 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, message &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 在 rdi 中的第一个整数（或者指针）</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;puts &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 输入文本 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 由 main 函数返回 C 语言库例程 </span><span class="pln"><br>message:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"Hola, mundo", 0 &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 注意到在 C 语言中字符串必须以 0 结束 </span></pre>
<pre class="console">$ <kbd>nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</kbd>
Hola, mundo
</pre>

<h2> 了解调用约束 </h2>

<p> 当你为 64 位 Linux 写一个集成了 C 语言库的程序时，你必须遵循以下的调用约束条件，详情可以参考 <a href="http://www.x86-64.org/documentation/abi.pdf">AMD64 ABI Reference</a>。你也可以从 <a href="http://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_Calling_Conventions">Wikipedia</a> 得到这些信息。在这里列出最重要的几点：</p>
<ul class="spaced">
<li> 传递参数时，按照从左到右的顺序，将尽可能多的参数依次保存在寄存器中。存放位置的寄存器顺序是确定的：
  <ul class="compressed">
    <li> 对于整数和指针，<code>rdi</code>，<code>rsi</code>，<code>rdx</code>，
        <code>rcx</code>，<code>r8</code>，<code>r9</code>。
    </li><li> 对于浮点数（float 和 double 类型），<code>xmm0</code>，<code>xmm1</code>，<code>xmm2</code>，
        <code>xmm3</code>，<code>xmm4</code>，<code>xmm5</code>，<code>xmm6</code>，<code>xmm7</code>。
  </li></ul>
</li>
<li> 剩下的参数将按照从右到左的顺序压入栈中，并在调用之后 <em> 由调用函数推出栈 </em>。</li>
<li> 等所有的参数传入后，会生成调用指令。所以当被调用函数得到控制权后，返回地址会被保存在 <code>[rsp]</code> 中，第一个局部变量会被保存在 <code>[rsp+8]</code> 中，以此类推。
</li>
<li><strong> 栈指针 <code>rsp</code> 在调用前必须进行 16 字节对齐处理 </strong>。当然，调用的过程中只会把一个 8 bytes 的返回地址推入栈中，所以当函数得到控制权时，<code>rsp</code> 并没有对齐。你需要向栈中压入数据或者从 <code>rsp</code> 减去 8 来使之对齐。</li>
<li> 调用函数需要保存如下的寄存器：<code>rbp</code>，<code>rbx</code>，<code>r12</code>，<code>r13</code>，<code>r14</code>，<code>r15</code>。其他的寄存器可以自由使用。</li>
<li> 被调用函数也需要保存 XMCSR 的控制位和 x87 指令集的控制字，但是 x87 指令在 64 位系统上十分少见所以你不必担心这点。</li>
<li> 整数返回值存放在 <code>rax</code> 或者 <code>rdx:rax</code> 中，浮点数返回值存放在 <code>xmm0</code> 或者 <code>xmm1:xmm0</code> 中。</li>
</ul>

<p> 下面是一个用来展示如何保存和恢复寄存器的程序：</p>

<div class="filename"><span>fib.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 一个输出 Fibonacci 数列前 90 项的 64 位 Linux 程序。</span><span class="pln"><br></span><span class="com">; 如何编译执行:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; &nbsp; nasm -felf64 fib.asm &amp;&amp; gcc fib.o &amp;&amp; ./a.out</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;printf<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>main:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 因为需要用 rbx 寄存器所以需要保存 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">ecx</span><span class="pln">, 90 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; ecx 作为计数器直至减到 0</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; rax 将记录当前的数字 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rbx</span><span class="pln">, </span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; rbx 将记录下一个的数字 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; inc &nbsp; &nbsp; </span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; rbx 初始值 1</span><span class="pln"><br>print:<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 我们需要调用 printf 函数, 但是我们也同时在使用 rax,rbx 和 rcx 这三个寄存器。</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 调用 printf 函数会破坏 rax 和 rcx 这两个寄存器的值, 所以我们要在调用前保存 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 并且在调用后恢复这两个寄存器中的数据。</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 调用者保存寄存器 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rcx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 调用者保存寄存器 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, format &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 设置第一个参数 (format)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 设置第二个参数 (current_number)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 因为 printf 是多参数的 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 栈内已经对齐, 因为我们压入了三个 8 字节的数据。</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;printf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; printf(format, current_number)</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rcx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 恢复调用者所保存的寄存器 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 恢复调用者所保存的寄存器 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdx</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 保存当前的数字 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 下一个数字保存在当前数字的位置 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rbx</span><span class="pln">, </span><span class="kwd">rdx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 计算得到下一个数字 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; </span><span class="kwd">ecx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; ecx 减 1</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; &nbsp; print &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 如果不是 0, 继续循环 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 返回前恢复 rbx 的值 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br>format:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp;"%20ld", 10, 0</span></pre>
<pre class="console">$ <kbd>nasm -felf64 fib.asm &amp;&amp; gcc fib.o &amp;&amp; ./a.out</kbd>
                   0
                   1
                   1
                   2
                   .
                   .
                   .
  679891637638612258
 1100087778366101931
 1779979416004714189
</pre>

<h2>C 和汇编的联合调用 </h2>

<p> 这是一个实现从三个整型参数中返回最大值函数的程序。</p>

<div class="filename"><span>maxofthree.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 一个返回三个数字中最大值的 64 位函数。</span><span class="pln"><br></span><span class="com">; 函数有如下形式:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; int64_t maxofthree(int64_t x, int64_t y, int64_t z)</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; 注意到参数通过 rdi, rsi 和 rdx 传递。</span><span class="pln"><br></span><span class="com">; 我们只需将返回值存放在 rax 中。</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;maxofthree<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>maxofthree:<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; rax 寄存器初始保存 x 的值 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; x 小于 y 吗?</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmovl &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 如果是的话, 返回值置为 y</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; x 和 y 中的最大值小于 z 吗?</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmovl &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 如果是的话, 返回值置为 z</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 最大值被存放在 rax 中 </span></pre>
<p> 下面是一个调用汇编函数的 C 程序。</p>

<div class="filename"><span>callmaxofthree.c</span></div><pre class="prettyprint"><span class="com">/*<br>&nbsp;* 这是一个用来展示我们如何调用在汇编语言中 <br>&nbsp;* 编写的 maxofthree 函数的程序。<br>&nbsp;*/</span><span class="pln"><br><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln"><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;inttypes.h&gt;</span><span class="pln"><br><br>int64_t maxofthree</span><span class="pun">(</span><span class="pln">int64_t</span><span class="pun">,</span><span class="pln"> int64_t</span><span class="pun">,</span><span class="pln"> int64_t</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">7</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">6</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(-</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">6</span><span class="pun">,</span><span class="pln"> </span><span class="lit">5</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br></span><span class="pun">}</span></pre>
<pre class="console">$ <kbd>nasm -felf64 maxofthree.asm &amp;&amp; gcc callmaxofthree.c maxofthree.o &amp;&amp; ./a.out</kbd>
1
2
3
4
5
6
</pre>

<h2> 命令行参数 </h2>

<p> 在 C 语言中，<code>main</code> 是一个古老而简单的函数，其实它自身可以附带一些参数：</p>
<pre>int main(int argc, char** argv)
</pre>
<p> 下面是一个运用这一点实现的简单每行输出一个命令行参数的函数：</p>

<div class="filename"><span>echo.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 一个显示命令行参数的 64 位程序。一行一个地输出。</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; 在函数入口处,rdi 保存 argc 的值,rsi 保存 argv 的值。</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;puts<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>main:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 保存 puts 函数需要用到的寄存器 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rsi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; sub &nbsp; &nbsp; </span><span class="kwd">rsp</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 调用函数前让栈顶对齐 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, [</span><span class="kwd">rsi</span><span class="pln">] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 需要输出的字符串参数 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;puts &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 调用 puts 输出 /span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rsp</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 恢复 %rsp 到未对齐前的值 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 恢复 puts 用到的寄存器 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 指向下一个参数 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 递减 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; &nbsp; main &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 如果未读完参数则继续 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br></span></pre>
<pre class="console">$ <kbd>nasm -felf64 echo.asm &amp;&amp; gcc echo.o &amp;&amp; ./a.out dog 22 -zzz "hi there"</kbd>
./a.out
dog
22
-zzz
hi there
</pre>

<h2> 一个更长一点的例子 </h2>

<p> 注意到就 C 语言库来说，命令行参数总是以字符串的形式传入的。如果你想把参数作为整型使用，调用 <code>atoi</code> 函数。下面是一个计算 x<sup>y</sup> 的函数。</p>

<div class="filename"><span>power.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 一个用于计算 x^y 的 64 位命令行程序。</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; 格式: power x y</span><span class="pln"><br></span><span class="com">; x 和 y 均为 32 位的正整数 </span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;printf<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;puts<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;atoi<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>main:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">r12</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 调用者保存寄存器 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">r13</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">r14</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 通过压入三个寄存器的值, 栈已经对齐 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 必须有且仅有 2 个参数 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jne &nbsp; &nbsp; error1<br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">r12</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; argv</span><span class="pln"><br><br></span><span class="com">; 我们将使用 ecx 作为指数的计数器, 直至 ecx 减到 0。</span><span class="pln"><br></span><span class="com">; 使用 esi 来保存基数, 使用 eax 保存乘积。</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, [</span><span class="kwd">r12</span><span class="pln">+16] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; argv[2]</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;atoi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; y 存放在 eax 中 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">eax</span><span class="pln">, 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 不允许负指数 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jl &nbsp; &nbsp; &nbsp;error2<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; r13d, </span><span class="kwd">eax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; y 存放在 r13d 中 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, [</span><span class="kwd">r12</span><span class="pln">+8] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; argv</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;atoi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; x 存放在 eax 中 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; r14d, </span><span class="kwd">eax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; x 存放在 r14d 中 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">eax</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 初始结果 answer = 1</span><span class="pln"><br>check:<br>&nbsp; &nbsp; &nbsp; &nbsp; test &nbsp; &nbsp;r13d, r13d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 递减 y 直至 0</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jz &nbsp; &nbsp; &nbsp;gotit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 完成 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; imul &nbsp; &nbsp;</span><span class="kwd">eax</span><span class="pln">, r14d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 再乘上一个 x</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; r13d<br>&nbsp; &nbsp; &nbsp; &nbsp; jmp &nbsp; &nbsp; check<br>gotit: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 输出成功信息 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, answer<br>&nbsp; &nbsp; &nbsp; &nbsp; movsxd &nbsp;</span><span class="kwd">rsi</span><span class="pln">, </span><span class="kwd">eax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;printf<br>&nbsp; &nbsp; &nbsp; &nbsp; jmp &nbsp; &nbsp; done<br>error1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 输出错误信息 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">edi</span><span class="pln">, badArgumentCount<br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;puts<br>&nbsp; &nbsp; &nbsp; &nbsp; jmp &nbsp; &nbsp; done<br>error2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 输出错误信息 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">edi</span><span class="pln">, negativeExponent<br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;puts<br>done: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 恢复所保存的寄存器 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">r14</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">r13</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">r12</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br><br>answer:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"%d", 10, 0<br>badArgumentCount:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"Requires exactly two arguments", 10, 0<br>negativeExponent:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"The exponent may not be negative", 10, 0</span></pre>
<pre class="console">$ <kbd>nasm -felf64 power.asm &amp;&amp; gcc -o power power.o</kbd>
$ <kbd>./power 2 19</kbd>
524288
$ <kbd>./power 3 -8</kbd>
The exponent may not be negative
$ <kbd>./power 1 500</kbd>
1
$ <kbd>./power 1</kbd>
Requires exactly two arguments
</pre>

<h2> 浮点数指令 </h2>

<p> 浮点数参数保存在 xmm 寄存器中。下面是一个用来计算存放在数组中的浮点数的和的简单的函数：</p>

<div class="filename"><span>sum.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 一个返回浮点数数组元素和的 64 位程序。</span><span class="pln"><br></span><span class="com">; 函数声明如下:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; double sum(double[] array, uint64_t length)</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;sum<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>sum:<br>&nbsp; &nbsp; &nbsp; &nbsp; xorsd &nbsp; </span><span class="kwd">xmm0</span><span class="pln">, </span><span class="kwd">xmm0</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 初始化累加和为 0</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln">, 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 考虑数组长度为 0 的特殊情形 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; je &nbsp; &nbsp; &nbsp;done<br>next:<br>&nbsp; &nbsp; &nbsp; &nbsp; addsd &nbsp; </span><span class="kwd">xmm0</span><span class="pln">, [</span><span class="kwd">rdi</span><span class="pln">] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 累加当前数组元素的值 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 指向下一个数组元素 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 计数器递减 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; &nbsp; next &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 如果没有结束递减则继续累加 </span><span class="pln"><br>done:<br>&nbsp; &nbsp; &nbsp; &nbsp; ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 返回保存在 xmm0 寄存器中的值 </span></pre>
<p> 这里有一个 C 程序调用汇编函数：</p>

<div class="filename"><span>callsum.c</span></div><pre class="prettyprint"><span class="com">/*<br>&nbsp;* 展示如何调用我们在汇编语言中编写的 sum 函数。<br>&nbsp;*/</span><span class="pln"><br><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln"><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;inttypes.h&gt;</span><span class="pln"><br><br></span><span class="kwd">double</span><span class="pln"> sum</span><span class="pun">(</span><span class="kwd">double</span><span class="pun">[],</span><span class="pln"> uint64_t</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">double</span><span class="pln"> test</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="lit">40.5</span><span class="pun">,</span><span class="pln"> </span><span class="lit">26.7</span><span class="pun">,</span><span class="pln"> </span><span class="lit">21.9</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.5</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">40.5</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">23.4</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">};</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%20.7f\n"</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">test</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%20.7f\n"</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">test</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%20.7f\n"</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">test</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%20.7f\n"</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">test</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br></span><span class="pun">}</span></pre>
<pre class="console">$ <kbd>nasm -felf64 sum.asm &amp;&amp; gcc sum.o callsum.c &amp;&amp; ./a.out</kbd>
          26.7000000
          67.2000000
           0.0000000
          89.1000000
</pre>

<h2> 数据段 </h2>

<p> 在大多数操作系统中，指令段是只读的，所以你需要使用数据段。数据段仅仅是被用来初始化数据，而且你可以发现一个叫做.bss 的段是存放未初始化过的数据的。下面是一个程序用来计算通过命令行参数传递的整数的平均值，并且以浮点数输出结果的程序。</p>

<div class="filename"><span>average.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 一个把参数当做整数处理, 并且以浮点数形式输出他们平均值的 64 位程序。</span><span class="pln"><br></span><span class="com">; 这个程序将使用一个数据段来保存中间结果。</span><span class="pln"><br></span><span class="com">; 这不是必须的, 但是在此我们想展示数据段是如何使用的。</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp; main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp; atoi<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp; printf<br>&nbsp; &nbsp; &nbsp; &nbsp; default &nbsp;rel<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section &nbsp;.text<br>main:<br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; argc-1, 因为我们不需要读入程序名称 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jz &nbsp; &nbsp; &nbsp; nothingToAverage<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;[count], </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 保存浮点数参数的个数 </span><span class="pln"><br>accumulate:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 保存调用 atoi 需要使用的寄存器 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln">, [</span><span class="kwd">rsi</span><span class="pln">+</span><span class="kwd">rdi</span><span class="pln">*8] &nbsp; &nbsp; &nbsp; </span><span class="com">; argv[rdi]</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp; atoi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 现在 rax 里保存着 arg 的整数值 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; &nbsp;</span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 调用完 atoi 函数后恢复寄存器 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; &nbsp;[sum], </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 继续累加 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 递减 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; &nbsp; &nbsp;accumulate &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 还有参数吗?</span><span class="pln"><br>average:<br>&nbsp; &nbsp; &nbsp; &nbsp; cvtsi2sd </span><span class="kwd">xmm0</span><span class="pln">, [sum]<br>&nbsp; &nbsp; &nbsp; &nbsp; cvtsi2sd </span><span class="kwd">xmm1</span><span class="pln">, [count]<br>&nbsp; &nbsp; &nbsp; &nbsp; divsd &nbsp; &nbsp;</span><span class="kwd">xmm0</span><span class="pln">, </span><span class="kwd">xmm1</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; xmm0 现在值为 sum/count</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln">, format &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; printf 的第一个参数 [注: 输出格式]</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; printf 是多参数的, 含有一个不是整数的参数 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; sub &nbsp; &nbsp; &nbsp;</span><span class="kwd">rsp</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 对齐栈指针 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp; printf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; printf(format, sum/count)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; &nbsp;</span><span class="kwd">rsp</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 恢复栈指针 </span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br><br>nothingToAverage:<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln">, error<br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp; printf<br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section &nbsp;.data<br>count: &nbsp;dq &nbsp; &nbsp; &nbsp; 0<br>sum: &nbsp; &nbsp;dq &nbsp; &nbsp; &nbsp; 0<br>format: db &nbsp; &nbsp; &nbsp; "%g", 10, 0<br>error: &nbsp;db &nbsp; &nbsp; &nbsp; "There are no command line arguments to average", 10, 0<br></span></pre>
<pre class="console">$ <kbd>nasm -felf64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out 19 8 21 -33</kbd>
3.75
$ <kbd>nasm -felf64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out</kbd>
There are no command line arguments to average
</pre>

<h2> 递归 </h2>

<p> 可能会让大家吃惊的是，事实上，实现一个递归并不需要什么特别的操作。你仅仅只需要像平时一样小心地保存寄存器的状态即可。</p>

<div class="filename"><span>factorial.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; ----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 一种递归函数的实现:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; uint64_t factorial(uint64_t n) {</span><span class="pln"><br></span><span class="com">; &nbsp; &nbsp; &nbsp; return (n &lt;= 1) ? 1 : n * factorial(n-1);</span><span class="pln"><br></span><span class="com">; &nbsp; }</span><span class="pln"><br></span><span class="com">; ----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;factorial<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>factorial:<br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; n &lt;= 1?</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnbe &nbsp; &nbsp;L1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 如果不是, 进行递归调用 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 否则, 返回 1</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br>L1:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 在栈上保存 n(同时对齐 %rsp 寄存器!)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; n-1</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;factorial &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; factorial(n-1), 返回值保存在 %rax 中 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; 保存 n</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; imul &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; n * factorial(n-1), 保存在 %rax 中 </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret</span></pre>
<p> 一个递归的例子：</p>

<div class="filename"><span>callfactorial.c</span></div><pre class="prettyprint"><span class="com">/*<br>&nbsp;* 这是一个调用在外部定义阶乘函数的程序 <br>&nbsp;*/</span><span class="pln"><br><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln"><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;inttypes.h&gt;</span><span class="pln"><br><br>uint64_t factorial</span><span class="pun">(</span><span class="pln">uint64_t n</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">uint64_t i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">20</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"factorial(%2lu) = %lu\n"</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> factorial</span><span class="pun">(</span><span class="pln">i</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br></span><span class="pun">}</span></pre>
<pre class="console">$ <kbd>nasm -felf64 factorial.asm &amp;&amp; gcc -std=c99 factorial.o callfactorial.c &amp;&amp; ./a.out</kbd>
factorial(0) = 1
factorial(1) = 1
factorial(2) = 2
factorial(3) = 6
factorial(4) = 24
factorial(5) = 120
factorial(6) = 720
factorial(7) = 5040
factorial(8) = 40320
factorial(9) = 362880
factorial(10) = 3628800
factorial(11) = 39916800
factorial(12) = 479001600
factorial(13) = 6227020800
factorial(14) = 87178291200
factorial(15) = 1307674368000
factorial(16) = 20922789888000
factorial(17) = 355687428096000
factorial(18) = 6402373705728000
factorial(19) = 121645100408832000
</pre>

<h2>SIMD 并行 </h2>

<p>XMM 寄存器一次可以对浮点数进行单个或多个操作。操作形式如下：</p>
<pre>operation  xmmregister_or_memorylocation, xmmregister
</pre>
<p> 对于浮点数加法，指令如下：:</p>
<pre>addpd — do 2 double-precision additions
addps — do just one double-precision addition, using the low 64-bits of the register
addsd — do 4 single-precision additions
addss — do just one single-precision addition, using the low 32-bits of the register
</pre>

<p>TODO - 举一个能一次处理数组中 4 个浮点数的函数的例子 </p>

<h2> 饱和运算 </h2>

<p>XMM 寄存器也可以进行整数运算。指令有如下形式：</p>
<pre>operation  xmmregister_or_memorylocation, xmmregister
</pre>
<p> 对于整数加法，指令如下：</p>
<pre>paddb — do 16 byte additions
paddw — do 8 word additions
paddd — do 4 dword additions
paddq — do 2 qword additions
paddsb — do 16 byte additions with signed saturation (80..7F)
paddsw — do 8 word additions with unsigned saturation (8000..7FFF)
paddusb — do 16 byte additions with unsigned saturation (00..FF)
paddusw — do 8 word additions with unsigned saturation (00..FFFF)
</pre>

<p>TODO - 举一个例子 </p>

<h2> 绘图 </h2>

<!--
<p>You probably the OpenGL graphics library already on your system, so
why not call it from an assembly language program:</p>
<div class='filename'><span>triangle.asm</span></div><pre class='prettyprint lang-asm'>; ----------------------------------------------------------------------------
; triangle.asm
;
; A very simple *Windows* OpenGL application using the GLUT library.  It
; draws a nicely colored triangle in a top-level application window.  One
; interesting thing is that the Windows GL and GLUT functions do NOT use the
; C calling convention; instead they use the "stdcall" convention which is
; like C except that the callee pops the parameters.
; ----------------------------------------------------------------------------
	global	_main
	extern	_glClear@4
	extern	_glBegin@4
	extern	_glEnd@0
	extern	_glColor3f@12
	extern	_glVertex3f@12
	extern	_glFlush@0
	extern	_glutInit@8
	extern	_glutInitDisplayMode@4
	extern	_glutInitWindowPosition@8
	extern	_glutInitWindowSize@8
	extern	_glutCreateWindow@4
	extern	_glutDisplayFunc@4
	extern	_glutMainLoop@0
	section	.text
title:	db	'A Simple Triangle', 0
zero:	dd	0.0
one:	dd	1.0
half:	dd	0.5
neghalf:dd	-0.5
display:
	push	dword 16384
	call	_glClear@4		; glClear(GL_COLOR_BUFFER_BIT)
	push	dword 9
	call	_glBegin@4		; glBegin(GL_POLYGON)
	push	dword 0
	push	dword 0
	push	dword [one]
	call	_glColor3f@12		; glColor3f(1, 0, 0)
	push	dword 0
	push	dword [neghalf]
	push	dword [neghalf]
	call	_glVertex3f@12		; glVertex(-.5, -.5, 0)
	push	dword 0
	push    dword [one]
	push	dword 0
	call	_glColor3f@12		; glColor3f(0, 1, 0)
	push	dword 0
	push	dword [neghalf]
	push	dword [half]
	call	_glVertex3f@12		; glVertex(.5, -.5, 0)
	push	dword [one]
	push	dword 0
	push	dword 0
	call	_glColor3f@12		; glColor3f(0, 0, 1)
	push	dword 0
	push	dword [half]
	push	dword 0
	call	_glVertex3f@12		; glVertex(0, .5, 0)
	call	_glEnd@0		; glEnd()
	call	_glFlush@0		; glFlush()
	ret
_main:
	push	dword [esp+8]		; push argv
	lea	eax, [esp+8]		; get addr of argc (offset changed :-)
	push	eax
	call	_glutInit@8		; glutInit(&amp;argc, argv)
	push	dword 0
	call	_glutInitDisplayMode@4
	push	dword 80
	push	dword 80
	call	_glutInitWindowPosition@8
	push	dword 300
	push	dword 400
	call	_glutInitWindowSize@8
	push	title
	call	_glutCreateWindow@4
	push	display
	call	_glutDisplayFunc@4
	call	_glutMainLoop@0
	ret
</pre> -->

 <p>TODO</p>

<h2> 局部变量与栈帧 </h2>

<p> 首先，请阅读 Eli Bendersky 的 <a href="http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/"> 这篇文章 </a>，会比这些摘要更加完整。
</p><p> 当一个函数被调用者调用时，调用者会先把参数存入正确的寄存器中，然后再执行 <code>call</code> 指令。无法放入寄存器中的参数将会在调用前被推入栈中。所调用的指令会把返回地址存入栈顶。所以如果有以下的函数：</p>

<pre class="prettyprint"><span class="pln">int64_t example</span><span class="pun">(</span><span class="pln">int64_t x</span><span class="pun">,</span><span class="pln"> int64_t y</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; int64_t a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">,</span><span class="pln"> c</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">7</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> x </span><span class="pun">*</span><span class="pln"> b </span><span class="pun">+</span><span class="pln"> y</span><span class="pun">;</span><span class="pln"><br></span><span class="pun">}</span></pre>

<p> 在函数的入口，x 和 y 会被分别存在 edi 和 esi 中，返回地址将会被存在栈顶。局部变量会被存到哪里？无论是否有足够的寄存器，一种简单的选择就是存入函数自己的栈中。</p>

<p> 如果程序运行在一个实现了 ABI 标准的机器上，你可以在 rsp 保持不变的情况下获取无法在寄存器中保存的参数值和局部变量值，例如：</p>

<pre>                +----------+
         rsp-24 |    a     |
                +----------+
         rsp-16 |    b     |
                +----------+
         rsp-8  |    c     |
                +----------+
         rsp    | retaddr  |
                +----------+
         rsp+8  | caller's |
                | stack    |
                | frame    |
                | ...      |
                +----------+
</pre>

<p> 我们的函数看上去是这个样子的：</p>
<pre class="prettyprint lang-asm"><span class="pln">&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;example<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>example:<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; qword [</span><span class="kwd">rsp</span><span class="pln">-16], 7<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; imul &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, [</span><span class="kwd">rsp</span><span class="pln">+8]<br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret</span></pre>

<p> 如果被调用的函数需要调用其他函数，你就需要调整 rsp 的值来得到正确的返回地址。</p>

<p> 在 Windows 上你可能无法使用这种方法，因为当中断发生的时候，栈指针上的数据会被抹去。而在其他大多数的操作系统中，这件事不会发生，因为有一个 128bytes 的 “红色区域” 来保护栈指针的安全。在这个例子中，你可以给栈留出空间：</p>

<pre class="prettyprint lang-gas"><span class="pln">example</span><span class="pun">:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">sub</span><span class="pln"> rsp</span><span class="pun">,</span><span class="pln"> </span><span class="lit">24</span></pre>

<p> 栈看上去是这个样子的：</p>

<pre>                +----------+
         rsp    |    a     |
                +----------+
         rsp+8  |    b     |
                +----------+
         rsp+16 |    c     |
                +----------+
         rsp+24 | retaddr  |
                +----------+
         rsp+32 | caller's |
                | stack    |
                | frame    |
                | ...      |
                +----------+
</pre>

<p> 下面就是我们的函数。注意到我们需要在返回前替换栈指针！</p>

<pre class="prettyprint lang-asm"><span class="pln">&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;example<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>example:<br>&nbsp; &nbsp; &nbsp; &nbsp; sub &nbsp; &nbsp; </span><span class="kwd">rsp</span><span class="pln">, 24<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; qword [</span><span class="kwd">rsp</span><span class="pln">+8], 7<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; imul &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, [</span><span class="kwd">rsp</span><span class="pln">+8]<br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rsp</span><span class="pln">, 24<br>&nbsp; &nbsp; &nbsp; &nbsp; ret</span></pre>

<h2> 在 OS X 下使用 NASM</h2>

<p>TODO</p>

<h2> 在 Windows 下使用 NASM</h2>

<p>TODO</p>


<script src="./lang-asm.js"></script>
</div>
</div>
<script>title = document.getElementsByTagName("h1")[0]; if (title) document.title = title.innerHTML;</script>


</body></html>
