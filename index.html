js<!DOCTYPE html>
<!-- saved from url=(0042)http://cs.lmu.edu/~ray/notes/nasmexamples/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>NASM Examples</title>
<link rel="stylesheet" type="text/css" href="./default.css">
<link rel="stylesheet" type="text/css" href="./prettify.css">
<script type="text/javascript" src="./prettify.js"></script><style type="text/css"></style>
</head>
<body class="coursenotes">
<script type="text/javascript">onload = prettyPrint;</script>
<div class="container">
<div class="innercontent">
<h1>NASM 示例</h1>

<div class="abstract">NASM是一个绝赞的汇编器。现在让我们通过一些例子来学习NASM。
然而这里的笔记仅仅只是蜻蜓点水般地涉及了一些皮毛，所以当你看完这个页面后，
你需要查看<a href="http://www.nasm.us/doc/">官方的NASM文档</a>。</div>

<h2>准备工作</h2>

<p>请注意：除了最后的几个部分，这里列举的所有例子需要运行在<strong>一个64位的Linux系统上</strong>。</p>

<p>请确保已经安装好nasm和gcc。</p>

<h2>入门</h2>

<p>我们的第一个程序将使用1号系统调用来输出一条信息并且使用60号系统调用来退出程序。</p>

<div class="filename"><span>hello.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; ----------------------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 仅使用系统调用来输出"Hello, World"到控制台。这个程序仅在64位的Linux下运行。</span><span class="pln"><br></span><span class="com">; 如何编译执行:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; &nbsp; nasm -felf64 hello.asm &amp;&amp; ld hello.o &amp;&amp; ./a.out</span><span class="pln"><br></span><span class="com">; ----------------------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;_start<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>_start:<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; write(1, message, 13)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; system call 1 is write</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; file handle 1 is stdout</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln">, message &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; address of string to output</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdx</span><span class="pln">, 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; number of bytes</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; syscall &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; invoke operating system to do the write</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; exit(0)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">eax</span><span class="pln">, 60 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; system call 60 is exit</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; exit code 0</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; syscall &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; invoke operating system to exit</span><span class="pln"><br>message:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"Hello, World", 10 &nbsp; &nbsp; &nbsp;</span><span class="com">; note the newline at the end</span></pre>
<pre class="console">$ <kbd>nasm -felf64 hello.asm &amp;&amp; ld hello.o &amp;&amp; ./a.out</kbd>
Hello, World
</pre>

<h2>调用一个C语言库</h2>

<p>记得C程序为何看上去总是从"main"函数开始执行吗？实际上，因为在C语言库的内部有一个<code>_start</code>标签!在<code>_start</code>处的代码首先会做一些初始化的工作，然后调用 <code>main</code> 函数，最后会做一些清理工作，最终执行60号系统系统调用。因此，你只需要实现 <code>main</code> 函数。我们在汇编中可以这么做：

</p><div class="filename"><span>hola.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; ----------------------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; Writes "Hola, mundo" to the console using a C library. Runs on Linux or any other system</span><span class="pln"><br></span><span class="com">; that does not use underscores for symbols in its C library. To assemble and run:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; &nbsp; nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><span class="pln"><br></span><span class="com">; ----------------------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;puts<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>main: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; This is called by the C library startup code</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, message &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; First integer (or pointer) argument in rdi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;puts &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; puts(message)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; Return from main back into C library wrapper</span><span class="pln"><br>message:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"Hola, mundo", 0 &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; Note strings must be terminated with 0 in C</span></pre>
<pre class="console">$ <kbd>nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</kbd>
Hola, mundo
</pre>

<h2>了解调用约束</h2>

<p>当你为64位Linux写一个集成了C语言库的程序时，你必须遵循以下的调用约束条件，详情可以参考<a href="http://www.x86-64.org/documentation/abi.pdf">AMD64 ABI Reference</a>。你也可以从<a href="http://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_Calling_Conventions">Wikipedia</a>得到这些信息。在这里列出最重要的几点：</p>
<ul class="spaced">
<li>传递参数时，按照从左到右的顺序，将尽可能多的参数依次保存在寄存器中。存放位置的寄存器顺序是确定的：
  <ul class="compressed">
    <li>对于整数和指针，<code>rdi</code>，<code>rsi</code>，<code>rdx</code>，
        <code>rcx</code>，<code>r8</code>，<code>r9</code>。
    </li><li>对于浮点数（float和double类型），<code>xmm0</code>，<code>xmm1</code>，<code>xmm2</code>，
        <code>xmm3</code>，<code>xmm4</code>，<code>xmm5</code>，<code>xmm6</code>，<code>xmm7</code>。
  </li></ul>
</li>
<li>剩下的参数将按照从右到左的顺序压入栈中，并在调用之后<em>由被调用函数推出栈</em>。</li>
<li>等所有的参数传入后，会生成调用指令。所以当被调用函数得到控制权后，返回地址会被保存在<code>[rsp]</code>中，第一个局部变量会被保存在<code>[rsp+8]</code>中，以此类推。
</li>
<li><strong>栈指针<code>rsp</code>在调用前必须进行16字节对齐处理</strong>。当然，调用的过程中只会把一个8 bytes的返回地址推入栈中，所以当函数得到控制权时，<code>rsp</code>并没有对齐。你需要向栈中压入数据或者从<code>rsp</code>减去8来使之对齐。</li>
<li>调用函数需要保存如下的寄存器：<code>rbp</code>，<code>rbx</code>，<code>r12</code>，<code>r13</code>，<code>r14</code>，<code>r15</code>。其他的寄存器可以自由使用。</li>
<li>被调用函数也需要保存XMCSR的控制位和x87指令集的控制字，但是x87指令在64位系统上十分少见所以你不必担心这点。</li>
<li>整数返回值存放在<code>rax</code>或者<code>rdx:rax</code>中，浮点数返回值存放在<code>xmm0</code>或者<code>xmm1:xmm0</code>中。</li>
</ul>

<p>下面是一个用来展示如何保存和恢复寄存器的程序：</p>

<div class="filename"><span>fib.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; A 64-bit Linux application that writes the first 90 Fibonacci numbers. To</span><span class="pln"><br></span><span class="com">; assemble and run:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; &nbsp; nasm -felf64 fib.asm &amp;&amp; gcc fib.o &amp;&amp; ./a.out</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;printf<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>main:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; we have to save this since we use it</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">ecx</span><span class="pln">, 90 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; ecx will countdown to 0</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; rax will hold the current number</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rbx</span><span class="pln">, </span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; rbx will hold the next number</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; inc &nbsp; &nbsp; </span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; rbx is originally 1</span><span class="pln"><br>print:<br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; We need to call printf, but we are using rax, rbx, and rcx. &nbsp;printf</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; may destroy rax and rcx so we will save these before the call and</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; restore them afterwards.</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; caller-save register</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rcx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; caller-save register</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, format &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; set 1st parameter (format)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; set 2nd parameter (current_number)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; because printf is varargs</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; Stack is already aligned because we pushed three 8 byte registers</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;printf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; printf(format, current_number)</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rcx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; restore caller-save register</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; restore caller-save register</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdx</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; save the current number</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; next number is now current</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rbx</span><span class="pln">, </span><span class="kwd">rdx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; get the new next number</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; </span><span class="kwd">ecx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; count down</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; &nbsp; print &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; if not done counting, do some more</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rbx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; restore rbx before returning</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br>format:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp;"%20ld", 10, 0</span></pre>
<pre class="console">$ <kbd>nasm -felf64 fib.asm &amp;&amp; gcc fib.o &amp;&amp; ./a.out</kbd>
                   0
                   1
                   1
                   2
                   .
                   .
                   .
  679891637638612258
 1100087778366101931
 1779979416004714189
</pre>

<h2>C和汇编的联合调用</h2>

<p>这是一个实现从三个整型参数中返回最大值函数的程序。</p>

<div class="filename"><span>maxofthree.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; A 64-bit function that returns the maximum value of its three 64-bit integer</span><span class="pln"><br></span><span class="com">; arguments. &nbsp;The function has signature:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; int64_t maxofthree(int64_t x, int64_t y, int64_t z)</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; Note that the parameters have already been passed in rdi, rsi, and rdx. &nbsp;We</span><span class="pln"><br></span><span class="com">; just have to return the value in rax.</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;maxofthree<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>maxofthree:<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; result (rax) initially holds x</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; is x less than y?</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmovl &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; if so, set result to y</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; is max(x,y) less than z?</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmovl &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdx</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; if so, set result to z</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; the max will be in rax</span></pre>
<p>下面是一个调用汇编函数的C程序。</p>

<div class="filename"><span>callmaxofthree.c</span></div><pre class="prettyprint"><span class="com">/*<br>&nbsp;* A small program that illustrates how to call the maxofthree function we wrote in<br>&nbsp;* assembly language.<br>&nbsp;*/</span><span class="pln"><br><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln"><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;inttypes.h&gt;</span><span class="pln"><br><br>int64_t maxofthree</span><span class="pun">(</span><span class="pln">int64_t</span><span class="pun">,</span><span class="pln"> int64_t</span><span class="pun">,</span><span class="pln"> int64_t</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">7</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">6</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(-</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">6</span><span class="pun">,</span><span class="pln"> </span><span class="lit">5</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%ld\n"</span><span class="pun">,</span><span class="pln"> maxofthree</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br></span><span class="pun">}</span></pre>
<pre class="console">$ <kbd>nasm -felf64 maxofthree.asm &amp;&amp; gcc callmaxofthree.c maxofthree.o &amp;&amp; ./a.out</kbd>
1
2
3
4
5
6
</pre>

<h2>命令行参数</h2>

<p>在C语言中，<code>main</code>是一个古老而简单的函数，其实它自身可以附带一些参数：</p>
<pre>int main(int argc, char** argv)
</pre>
<p>下面是一个运用这一点实现的简单每行输出一个命令行参数的函数：</p>

<div class="filename"><span>echo.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; A 64-bit program that displays its command line arguments, one per line.</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; On entry, rdi will contain argc and rsi will contain argv.</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;puts<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>main:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; save registers that puts uses</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rsi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; sub &nbsp; &nbsp; </span><span class="kwd">rsp</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; must align stack before call</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, [</span><span class="kwd">rsi</span><span class="pln">] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; the argument string to display</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;puts &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; print it</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rsp</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; restore %rsp to pre-aligned value</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; restore registers puts used</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; point to next argument</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; count down</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; &nbsp; main &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; if not done counting keep going</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br></span></pre>
<pre class="console">$ <kbd>nasm -felf64 echo.asm &amp;&amp; gcc echo.o &amp;&amp; ./a.out dog 22 -zzz "hi there"</kbd>
./a.out
dog
22
-zzz
hi there
</pre>

<h2>一个更长一点的例子</h2>

<p>注意到就C语言库来说，命令行参数总是以字符串的形式传入的。如果你想把参数作为整型使用，调用<code>atoi</code>函数。下面是一个计算x<sup>y</sup>的函数。</p>

<div class="filename"><span>power.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; A 64-bit command line application to compute x^y.</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; Syntax: power x y</span><span class="pln"><br></span><span class="com">; x and y are (32-bit) integers</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;printf<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;puts<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp;atoi<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>main:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">r12</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; save callee-save registers</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">r13</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">r14</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; By pushing 3 registers our stack is already aligned for calls</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; must have exactly two arguments</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jne &nbsp; &nbsp; error1<br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">r12</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; argv</span><span class="pln"><br><br></span><span class="com">; We will use ecx to count down form the exponent to zero, esi to hold the</span><span class="pln"><br></span><span class="com">; value of the base, and eax to hold the running product.</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, [</span><span class="kwd">r12</span><span class="pln">+16] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; argv[2]</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;atoi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; y in eax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">eax</span><span class="pln">, 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; disallow negative exponents</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jl &nbsp; &nbsp; &nbsp;error2<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; r13d, </span><span class="kwd">eax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; y in r13d</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, [</span><span class="kwd">r12</span><span class="pln">+8] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; argv</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;atoi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; x in eax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; r14d, </span><span class="kwd">eax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; x in r14d</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">eax</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; start with answer = 1</span><span class="pln"><br>check:<br>&nbsp; &nbsp; &nbsp; &nbsp; test &nbsp; &nbsp;r13d, r13d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; we're counting y downto 0</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jz &nbsp; &nbsp; &nbsp;gotit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; done</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; imul &nbsp; &nbsp;</span><span class="kwd">eax</span><span class="pln">, r14d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; multiply in another x</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; r13d<br>&nbsp; &nbsp; &nbsp; &nbsp; jmp &nbsp; &nbsp; check<br>gotit: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; print report on success</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, answer<br>&nbsp; &nbsp; &nbsp; &nbsp; movsxd &nbsp;</span><span class="kwd">rsi</span><span class="pln">, </span><span class="kwd">eax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;printf<br>&nbsp; &nbsp; &nbsp; &nbsp; jmp &nbsp; &nbsp; done<br>error1: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; print error message</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">edi</span><span class="pln">, badArgumentCount<br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;puts<br>&nbsp; &nbsp; &nbsp; &nbsp; jmp &nbsp; &nbsp; done<br>error2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; print error message</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">edi</span><span class="pln">, negativeExponent<br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;puts<br>done: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; restore saved registers</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">r14</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">r13</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">r12</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br><br>answer:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"%d", 10, 0<br>badArgumentCount:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"Requires exactly two arguments", 10, 0<br>negativeExponent:<br>&nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;"The exponent may not be negative", 10, 0</span></pre>
<pre class="console">$ <kbd>nasm -felf64 power.asm &amp;&amp; gcc -o power power.o</kbd>
$ <kbd>./power 2 19</kbd>
524288
$ <kbd>./power 3 -8</kbd>
The exponent may not be negative
$ <kbd>./power 1 500</kbd>
1
$ <kbd>./power 1</kbd>
Requires exactly two arguments
</pre>

<h2>浮点数指令</h2>

<p>浮点数参数保存在xmm寄存器中。下面是一个用来计算存放在数组中的浮点数的和的简单的函数：</p>

<div class="filename"><span>sum.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; A 64-bit function that returns the sum of the elements in a floating-point</span><span class="pln"><br></span><span class="com">; array. The function has prototype:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; double sum(double[] array, uint64_t length)</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;sum<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>sum:<br>&nbsp; &nbsp; &nbsp; &nbsp; xorsd &nbsp; </span><span class="kwd">xmm0</span><span class="pln">, </span><span class="kwd">xmm0</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; initialize the sum to 0</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln">, 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; special case for length = 0</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; je &nbsp; &nbsp; &nbsp;done<br>next:<br>&nbsp; &nbsp; &nbsp; &nbsp; addsd &nbsp; </span><span class="kwd">xmm0</span><span class="pln">, [</span><span class="kwd">rdi</span><span class="pln">] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; add in the current array element</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; move to next array element</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; count down</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; &nbsp; next &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; if not done counting, continue</span><span class="pln"><br>done:<br>&nbsp; &nbsp; &nbsp; &nbsp; ret &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; return value already in xmm0</span></pre>
<p>这里有一个C程序调用汇编函数：</p>

<div class="filename"><span>callsum.c</span></div><pre class="prettyprint"><span class="com">/*<br>&nbsp;* Illustrates how to call the sum function we wrote in assembly language.<br>&nbsp;*/</span><span class="pln"><br><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln"><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;inttypes.h&gt;</span><span class="pln"><br><br></span><span class="kwd">double</span><span class="pln"> sum</span><span class="pun">(</span><span class="kwd">double</span><span class="pun">[],</span><span class="pln"> uint64_t</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">double</span><span class="pln"> test</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="lit">40.5</span><span class="pun">,</span><span class="pln"> </span><span class="lit">26.7</span><span class="pun">,</span><span class="pln"> </span><span class="lit">21.9</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.5</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">40.5</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">23.4</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">};</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%20.7f\n"</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">test</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%20.7f\n"</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">test</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%20.7f\n"</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">test</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"%20.7f\n"</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">test</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br></span><span class="pun">}</span></pre>
<pre class="console">$ <kbd>nasm -felf64 sum.asm &amp;&amp; gcc sum.o callsum.c &amp;&amp; ./a.out</kbd>
          26.7000000
          67.2000000
           0.0000000
          89.1000000
</pre>

<h2>数据段</h2>

<p>在大多数操作系统中，指令段是只读的，所以你需要使用数据段。数据段仅仅是被用来初始化数据，而且你可以发现一个叫做.bss的段是存放未初始化过的数据的。下面是一个程序用来计算通过命令行参数传递的整数的平均值，并且以浮点数输出结果的程序。</p>

<div class="filename"><span>average.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; 64-bit program that treats all its command line arguments as integers and</span><span class="pln"><br></span><span class="com">; displays their average as a floating point number. &nbsp;This program uses a data</span><span class="pln"><br></span><span class="com">; section to store intermediate results, not that it has to, but only to</span><span class="pln"><br></span><span class="com">; illustrate how data sections are used.</span><span class="pln"><br></span><span class="com">; -----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp; main<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp; atoi<br>&nbsp; &nbsp; &nbsp; &nbsp; extern &nbsp; printf<br>&nbsp; &nbsp; &nbsp; &nbsp; default &nbsp;rel<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section &nbsp;.text<br>main:<br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; argc-1, since we don't count program name</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jz &nbsp; &nbsp; &nbsp; nothingToAverage<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;[count], </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; save number of real arguments</span><span class="pln"><br>accumulate:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; save register across call to atoi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp; </span><span class="kwd">rsi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln">, [</span><span class="kwd">rsi</span><span class="pln">+</span><span class="kwd">rdi</span><span class="pln">*8] &nbsp; &nbsp; &nbsp; </span><span class="com">; argv[rdi]</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp; atoi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; now rax has the int value of arg</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; &nbsp;</span><span class="kwd">rsi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; restore registers after atoi call</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; &nbsp;[sum], </span><span class="kwd">rax</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; accumulate sum as we go</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; count down</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnz &nbsp; &nbsp; &nbsp;accumulate &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; more arguments?</span><span class="pln"><br>average:<br>&nbsp; &nbsp; &nbsp; &nbsp; cvtsi2sd </span><span class="kwd">xmm0</span><span class="pln">, [sum]<br>&nbsp; &nbsp; &nbsp; &nbsp; cvtsi2sd </span><span class="kwd">xmm1</span><span class="pln">, [count]<br>&nbsp; &nbsp; &nbsp; &nbsp; divsd &nbsp; &nbsp;</span><span class="kwd">xmm0</span><span class="pln">, </span><span class="kwd">xmm1</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; xmm0 is sum/count</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln">, format &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; 1st arg to printf</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; printf is varargs, there is 1 non-int argument</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; sub &nbsp; &nbsp; &nbsp;</span><span class="kwd">rsp</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; align stack pointer</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp; printf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; printf(format, sum/count)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; &nbsp;</span><span class="kwd">rsp</span><span class="pln">, 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; restore stack pointer</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br><br>nothingToAverage:<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln">, error<br>&nbsp; &nbsp; &nbsp; &nbsp; xor &nbsp; &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp; printf<br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section &nbsp;.data<br>count: &nbsp;dq &nbsp; &nbsp; &nbsp; 0<br>sum: &nbsp; &nbsp;dq &nbsp; &nbsp; &nbsp; 0<br>format: db &nbsp; &nbsp; &nbsp; "%g", 10, 0<br>error: &nbsp;db &nbsp; &nbsp; &nbsp; "There are no command line arguments to average", 10, 0<br></span></pre>
<pre class="console">$ <kbd>nasm -felf64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out 19 8 21 -33</kbd>
3.75
$ <kbd>nasm -felf64 average.asm &amp;&amp; gcc average.o &amp;&amp; ./a.out</kbd>
There are no command line arguments to average
</pre>

<h2>递归</h2>

<p>可能让大家吃惊的是，事实上，实现一个递归并不需要什么特别的操作。你仅仅只需要像平时一样小心地保存寄存器的状态即可。</p>

<div class="filename"><span>factorial.asm</span></div><pre class="prettyprint lang-asm"><span class="com">; ----------------------------------------------------------------------------</span><span class="pln"><br></span><span class="com">; An implementation of the recursive function:</span><span class="pln"><br></span><span class="com">;</span><span class="pln"><br></span><span class="com">; &nbsp; uint64_t factorial(uint64_t n) {</span><span class="pln"><br></span><span class="com">; &nbsp; &nbsp; &nbsp; return (n &lt;= 1) ? 1 : n * factorial(n-1);</span><span class="pln"><br></span><span class="com">; &nbsp; }</span><span class="pln"><br></span><span class="com">; ----------------------------------------------------------------------------</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;factorial<br><br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>factorial:<br>&nbsp; &nbsp; &nbsp; &nbsp; cmp &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; n &lt;= 1?</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; jnbe &nbsp; &nbsp;L1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; if not, go do a recursive call</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; otherwise return 1</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret<br>L1:<br>&nbsp; &nbsp; &nbsp; &nbsp; push &nbsp; &nbsp;</span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; save n on stack (also aligns %rsp!)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; dec &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; n-1</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; &nbsp;factorial &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; factorial(n-1), result goes in %rax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; pop &nbsp; &nbsp; </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">; restore n</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; imul &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">; n * factorial(n-1), stored in %rax</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret</span></pre>
<p>一个递归的例子：</p>

<div class="filename"><span>callfactorial.c</span></div><pre class="prettyprint"><span class="com">/*<br>&nbsp;* An application that illustrates calling the factorial function defined elsewhere.<br>&nbsp;*/</span><span class="pln"><br><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln"><br></span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;inttypes.h&gt;</span><span class="pln"><br><br>uint64_t factorial</span><span class="pun">(</span><span class="pln">uint64_t n</span><span class="pun">);</span><span class="pln"><br><br></span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">uint64_t i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">20</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; printf</span><span class="pun">(</span><span class="str">"factorial(%2lu) = %lu\n"</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> factorial</span><span class="pun">(</span><span class="pln">i</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br></span><span class="pun">}</span></pre>
<pre class="console">$ <kbd>nasm -felf64 factorial.asm &amp;&amp; gcc -std=c99 factorial.o callfactorial.c &amp;&amp; ./a.out</kbd>
factorial( 0) = 1
factorial( 1) = 1
factorial( 2) = 2
factorial( 3) = 6
factorial( 4) = 24
factorial( 5) = 120
factorial( 6) = 720
factorial( 7) = 5040
factorial( 8) = 40320
factorial( 9) = 362880
factorial(10) = 3628800
factorial(11) = 39916800
factorial(12) = 479001600
factorial(13) = 6227020800
factorial(14) = 87178291200
factorial(15) = 1307674368000
factorial(16) = 20922789888000
factorial(17) = 355687428096000
factorial(18) = 6402373705728000
factorial(19) = 121645100408832000
</pre>

<h2>SIMD并行</h2>

<p>XMM寄存器一次可以对浮点数进行单个或多个操作。操作形式如下：</p>
<pre>operation  xmmregister_or_memorylocation, xmmregister
</pre>
<p>对于浮点数加法，指令如下：:</p>
<pre>addpd — do 2 double-precision additions
addps — do just one double-precision addition, using the low 64-bits of the register
addsd — do 4 single-precision additions
addss — do just one single-precision addition, using the low 32-bits of the register
</pre>

<p>TODO - 举一个能一次处理数组中4个浮点数的函数的例子</p>

<h2>饱和运算</h2>

<p>XMM寄存器也可以进行整数运算。指令有如下形式：</p>
<pre>operation  xmmregister_or_memorylocation, xmmregister
</pre>
<p>对于整数加法，指令如下：</p>
<pre>paddb — do 16 byte additions
paddw — do 8 word additions
paddd — do 4 dword additions
paddq — do 2 qword additions
paddsb — do 16 byte additions with signed saturation (80..7F)
paddsw — do 8 word additions with unsigned saturation (8000..7FFF)
paddusb — do 16 byte additions with unsigned saturation (00..FF)
paddusw — do 8 word additions with unsigned saturation (00..FFFF)
</pre>

<p>TODO - 举一个例子</p>

<h2>绘图</h2>

<!--
<p>You probably the OpenGL graphics library already on your system, so
why not call it from an assembly language program:</p>

<div class='filename'><span>triangle.asm</span></div><pre class='prettyprint lang-asm'>; ----------------------------------------------------------------------------
; triangle.asm
;
; A very simple *Windows* OpenGL application using the GLUT library.  It
; draws a nicely colored triangle in a top-level application window.  One
; interesting thing is that the Windows GL and GLUT functions do NOT use the
; C calling convention; instead they use the "stdcall" convention which is
; like C except that the callee pops the parameters.
; ----------------------------------------------------------------------------

	global	_main
	extern	_glClear@4
	extern	_glBegin@4
	extern	_glEnd@0
	extern	_glColor3f@12
	extern	_glVertex3f@12
	extern	_glFlush@0
	extern	_glutInit@8
	extern	_glutInitDisplayMode@4
	extern	_glutInitWindowPosition@8
	extern	_glutInitWindowSize@8
	extern	_glutCreateWindow@4
	extern	_glutDisplayFunc@4
	extern	_glutMainLoop@0

	section	.text
title:	db	'A Simple Triangle', 0
zero:	dd	0.0
one:	dd	1.0
half:	dd	0.5
neghalf:dd	-0.5

display:
	push	dword 16384
	call	_glClear@4		; glClear(GL_COLOR_BUFFER_BIT)
	push	dword 9
	call	_glBegin@4		; glBegin(GL_POLYGON)
	push	dword 0
	push	dword 0
	push	dword [one]
	call	_glColor3f@12		; glColor3f(1, 0, 0)
	push	dword 0
	push	dword [neghalf]
	push	dword [neghalf]
	call	_glVertex3f@12		; glVertex(-.5, -.5, 0)
	push	dword 0
	push    dword [one]
	push	dword 0
	call	_glColor3f@12		; glColor3f(0, 1, 0)
	push	dword 0
	push	dword [neghalf]
	push	dword [half]
	call	_glVertex3f@12		; glVertex(.5, -.5, 0)
	push	dword [one]
	push	dword 0
	push	dword 0
	call	_glColor3f@12		; glColor3f(0, 0, 1)
	push	dword 0
	push	dword [half]
	push	dword 0
	call	_glVertex3f@12		; glVertex(0, .5, 0)
	call	_glEnd@0		; glEnd()
	call	_glFlush@0		; glFlush()
	ret

_main:
	push	dword [esp+8]		; push argv
	lea	eax, [esp+8]		; get addr of argc (offset changed :-)
	push	eax
	call	_glutInit@8		; glutInit(&amp;argc, argv)
	push	dword 0
	call	_glutInitDisplayMode@4
	push	dword 80
	push	dword 80
	call	_glutInitWindowPosition@8
	push	dword 300
	push	dword 400
	call	_glutInitWindowSize@8
	push	title
	call	_glutCreateWindow@4
	push	display
	call	_glutDisplayFunc@4
	call	_glutMainLoop@0
	ret
</pre> -->

 <p>TODO</p>

<h2>局部变量与栈帧</h2>

<p>首先，请阅读Eli Bendersky的<a href="http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/">这篇文章</a>，会比这些摘要更加完整。
</p><p>当一个函数被调用者调用时，调用者会先把参数存入正确的寄存器中，然后再执行<code>call</code>指令。无法放入寄存器中的参数将会在调用前被推入栈中。所调用的指令会把返回地址存入栈顶。所以如果有以下的函数：</p>

<pre class="prettyprint"><span class="pln">int64_t example</span><span class="pun">(</span><span class="pln">int64_t x</span><span class="pun">,</span><span class="pln"> int64_t y</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; int64_t a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">,</span><span class="pln"> c</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">7</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> x </span><span class="pun">*</span><span class="pln"> b </span><span class="pun">+</span><span class="pln"> y</span><span class="pun">;</span><span class="pln"><br></span><span class="pun">}</span></pre>

<p>在函数的入口，x和y会被分别存在edi和esi中，返回地址将会被存在栈顶。局部变量会被存到哪里？无论是否有足够的寄存器，一种简单的选择就是存入函数自己的栈中。</p>

<p>如果程序运行在一个实现了ABI标准的机器上，你可以在rsp保持不变的情况下获取无法在寄存器中保存的参数值和局部变量值，例如：</p>

<pre>                +----------+
         rsp-24 |    a     |
                +----------+
         rsp-16 |    b     |
                +----------+
         rsp-8  |    c     |
                +----------+
         rsp    | retaddr  |
                +----------+
         rsp+8  | caller's |
                | stack    |
                | frame    |
                | ...      |
                +----------+
</pre>

<p>我们的函数看上去是这个样子的：</p>
<pre class="prettyprint lang-asm"><span class="pln">&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;example<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>example:<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; qword [</span><span class="kwd">rsp</span><span class="pln">-16], 7<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; imul &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, [</span><span class="kwd">rsp</span><span class="pln">+8]<br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; ret</span></pre>

<p>如果被调用的函数需要调用其他函数，你就需要调整rsp的值来得到正确的返回地址。</p>

<p>在Windows上你可能无法使用这种方法，因为当中断发生的时候，栈指针上的数据会被抹去。而在其他大多数的操作系统中，这件事不会发生，因为有一个128bytes的“红色区域”来保护栈指针的安全。在这个例子中，你可以给栈留出空间：</p>

<pre class="prettyprint lang-gas"><span class="pln">example</span><span class="pun">:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">sub</span><span class="pln"> rsp</span><span class="pun">,</span><span class="pln"> </span><span class="lit">24</span></pre>

<p>栈看上去是这个样子的：</p>

<pre>                +----------+
         rsp    |    a     |
                +----------+
         rsp+8  |    b     |
                +----------+
         rsp+16 |    c     |
                +----------+
         rsp+24 | retaddr  |
                +----------+
         rsp+32 | caller's |
                | stack    |
                | frame    |
                | ...      |
                +----------+
</pre>

<p>下面就是我们的函数。注意到我们需要在返回前替换栈指针！</p>

<pre class="prettyprint lang-asm"><span class="pln">&nbsp; &nbsp; &nbsp; &nbsp; global &nbsp;example<br>&nbsp; &nbsp; &nbsp; &nbsp; section .text<br>example:<br>&nbsp; &nbsp; &nbsp; &nbsp; sub &nbsp; &nbsp; </span><span class="kwd">rsp</span><span class="pln">, 24<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; qword [</span><span class="kwd">rsp</span><span class="pln">+8], 7<br>&nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rdi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; imul &nbsp; &nbsp;</span><span class="kwd">rax</span><span class="pln">, [</span><span class="kwd">rsp</span><span class="pln">+8]<br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rax</span><span class="pln">, </span><span class="kwd">rsi</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; add &nbsp; &nbsp; </span><span class="kwd">rsp</span><span class="pln">, 24<br>&nbsp; &nbsp; &nbsp; &nbsp; ret</span></pre>

<h2>在OS X下使用NASM</h2>

<p>TODO</p>

<h2>在Windows下使用NASM</h2>

<p>TODO</p>


<script src="./lang-asm.js"></script>
</div>
</div>
<script>title = document.getElementsByTagName("h1")[0]; if (title) document.title = title.innerHTML;</script>


</body></html>